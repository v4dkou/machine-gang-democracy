// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Hakathon Swagger API
 * API for autogenerator
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

export const TOKEN_KEY = "Authorization";

/**
 *
 * @export
 * @interface Advertisement
 */
export interface Advertisement {
    /**
     *
     * @type {AdvertisementSubcategory}
     * @memberof Advertisement
     */
    subcategory: AdvertisementSubcategory;
    /**
     *
     * @type {string}
     * @memberof Advertisement
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof Advertisement
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof Advertisement
     */
    image?: string;
    /**
     *
     * @type {number}
     * @memberof Advertisement
     */
    price?: number;
    /**
     *
     * @type {number}
     * @memberof Advertisement
     */
    range?: number;
    /**
     *
     * @type {boolean}
     * @memberof Advertisement
     */
    isPaid: boolean;
    /**
     *
     * @type {number}
     * @memberof Advertisement
     */
    paidPeriod?: number;
}
/**
 *
 * @export
 * @interface AdvertisementCategory
 */
export interface AdvertisementCategory {
    /**
     *
     * @type {number}
     * @memberof AdvertisementCategory
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof AdvertisementCategory
     */
    name?: string;
    /**
     *
     * @type {Array<AdvertisementSubcategory>}
     * @memberof AdvertisementCategory
     */
    subcategories?: Array<AdvertisementSubcategory>;
    /**
     *
     * @type {string}
     * @memberof AdvertisementCategory
     */
    promo?: string;
}
/**
 *
 * @export
 * @interface AdvertisementSubcategory
 */
export interface AdvertisementSubcategory {
    /**
     *
     * @type {number}
     * @memberof AdvertisementSubcategory
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof AdvertisementSubcategory
     */
    name?: string;
}
/**
 *
 * @export
 * @interface Announcement
 */
export interface Announcement {
    /**
     *
     * @type {DiscussionTopic}
     * @memberof Announcement
     */
    topic?: DiscussionTopic;
    /**
     *
     * @type {string}
     * @memberof Announcement
     */
    announcementDescription: string;
}
/**
 *
 * @export
 * @interface Chat
 */
export interface Chat {
    /**
     *
     * @type {number}
     * @memberof Chat
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof Chat
     */
    name?: string | null;
}
/**
 *
 * @export
 * @interface DiscussionTopic
 */
export interface DiscussionTopic {
    /**
     *
     * @type {number}
     * @memberof DiscussionTopic
     */
    id?: number;
    /**
     *
     * @type {User}
     * @memberof DiscussionTopic
     */
    user?: User;
    /**
     *
     * @type {number}
     * @memberof DiscussionTopic
     */
    chat?: number;
    /**
     *
     * @type {string}
     * @memberof DiscussionTopic
     */
    description: string;
    /**
     *
     * @type {boolean}
     * @memberof DiscussionTopic
     */
    alert?: boolean;
    /**
     *
     * @type {string}
     * @memberof DiscussionTopic
     */
    status?: DiscussionTopicStatusEnum;
    /**
     *
     * @type {string}
     * @memberof DiscussionTopic
     */
    initiative?: string;
    /**
     *
     * @type {string}
     * @memberof DiscussionTopic
     */
    announcement?: string;
    /**
     *
     * @type {Date}
     * @memberof DiscussionTopic
     */
    dateCreated?: Date;
    /**
     *
     * @type {Date}
     * @memberof DiscussionTopic
     */
    dateUpdated?: Date;
}

/**
    * @export
    * @enum {string}
    */
export enum DiscussionTopicStatusEnum {
    New = 'new',
    Voting = 'voting',
    Closed = 'closed'
}

/**
 *
 * @export
 * @interface Initiative
 */
export interface Initiative {
    /**
     *
     * @type {DiscussionTopic}
     * @memberof Initiative
     */
    topic?: DiscussionTopic;
    /**
     *
     * @type {string}
     * @memberof Initiative
     */
    problemDescription: string;
    /**
     *
     * @type {string}
     * @memberof Initiative
     */
    solutionDescription: string;
    /**
     *
     * @type {string}
     * @memberof Initiative
     */
    feedback?: string;
    /**
     *
     * @type {Array<InitiativeProcessStep>}
     * @memberof Initiative
     */
    steps?: Array<InitiativeProcessStep>;
    /**
     *
     * @type {string}
     * @memberof Initiative
     */
    votes?: string;
    /**
     *
     * @type {string}
     * @memberof Initiative
     */
    relevance?: string;
}
/**
 *
 * @export
 * @interface InitiativeFeedback
 */
export interface InitiativeFeedback {
    /**
     *
     * @type {number}
     * @memberof InitiativeFeedback
     */
    relevance?: number;
    /**
     *
     * @type {boolean}
     * @memberof InitiativeFeedback
     */
    vote?: boolean | null;
}
/**
 *
 * @export
 * @interface InitiativeProcessStep
 */
export interface InitiativeProcessStep {
    /**
     *
     * @type {number}
     * @memberof InitiativeProcessStep
     */
    orderCol?: number;
    /**
     *
     * @type {string}
     * @memberof InitiativeProcessStep
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof InitiativeProcessStep
     */
    status?: InitiativeProcessStepStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InitiativeProcessStepStatusEnum {
    New = 'new',
    Complete = 'complete'
}

/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse200
     */
    next?: string | null;
    /**
     *
     * @type {string}
     * @memberof InlineResponse200
     */
    previous?: string | null;
    /**
     *
     * @type {Array<DiscussionTopic>}
     * @memberof InlineResponse200
     */
    results: Array<DiscussionTopic>;
}
/**
 *
 * @export
 * @interface JSONWebToken
 */
export interface JSONWebToken {
    /**
     *
     * @type {string}
     * @memberof JSONWebToken
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof JSONWebToken
     */
    password: string;
}

/**
 *
 * @export
 * @interface JSONWebTokenResponse
 */
export interface JSONWebTokenResponse {
    /**
     *
     * @type {string}
     * @memberof JSONWebTokenResponse
     */
    token: string;

    /**
     *
     * @type {User}
     * @memberof JSONWebTokenResponse
     */
    user: User;
}
/**
 *
 * @export
 * @interface Message
 */
export interface Message {
    /**
     *
     * @type {number}
     * @memberof Message
     */
    id?: number;
    /**
     *
     * @type {User}
     * @memberof Message
     */
    user?: User;
    /**
     *
     * @type {number}
     * @memberof Message
     */
    chat: number;
    /**
     *
     * @type {string}
     * @memberof Message
     */
    text: string;
}
/**
 *
 * @export
 * @interface RefreshJSONWebToken
 */
export interface RefreshJSONWebToken {
    /**
     *
     * @type {string}
     * @memberof RefreshJSONWebToken
     */
    token: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     *
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof User
     */
    username: string;
}
/**
 *
 * @export
 * @interface UserDevice
 */
export interface UserDevice {
    /**
     *
     * @type {number}
     * @memberof UserDevice
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof UserDevice
     */
    deviceType: UserDeviceDeviceTypeEnum;
    /**
     *
     * @type {string}
     * @memberof UserDevice
     */
    deviceId: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserDeviceDeviceTypeEnum {
    IosDev = 'ios-dev',
    Ios = 'ios',
    Gcm = 'gcm'
}


/**
 * AdvertisementCategoriesApi - axios parameter creator
 * @export
 */
export const AdvertisementCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advertisementCategoriesList(options: any = {}): RequestArgs {
            const localVarPath = `/advertisement_categories/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdvertisementCategoriesApi - functional programming interface
 * @export
 */
export const AdvertisementCategoriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advertisementCategoriesList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdvertisementCategory>> {
            const localVarAxiosArgs = AdvertisementCategoriesApiAxiosParamCreator(configuration).advertisementCategoriesList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdvertisementCategoriesApi - factory interface
 * @export
 */
export const AdvertisementCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advertisementCategoriesList(options?: any) {
            return AdvertisementCategoriesApiFp(configuration).advertisementCategoriesList(options)(axios, basePath);
        },
    };
};

/**
 * AdvertisementCategoriesApi - object-oriented interface
 * @export
 * @class AdvertisementCategoriesApi
 * @extends {BaseAPI}
 */
export class AdvertisementCategoriesApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvertisementCategoriesApi
     */
    public advertisementCategoriesList(options?: any) {
        return AdvertisementCategoriesApiFp(this.configuration).advertisementCategoriesList(options)(this.axios, this.basePath);
    }

}


/**
 * AdvertisementsApi - axios parameter creator
 * @export
 */
export const AdvertisementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Advertisement} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advertisementsCreate(data: Advertisement, options: any = {}): RequestArgs {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling advertisementsCreate.');
            }
            const localVarPath = `/advertisements/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"Advertisement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advertisementsList(options: any = {}): RequestArgs {
            const localVarPath = `/advertisements/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdvertisementsApi - functional programming interface
 * @export
 */
export const AdvertisementsApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {Advertisement} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advertisementsCreate(data: Advertisement, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Advertisement> {
            const localVarAxiosArgs = AdvertisementsApiAxiosParamCreator(configuration).advertisementsCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advertisementsList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Advertisement>> {
            const localVarAxiosArgs = AdvertisementsApiAxiosParamCreator(configuration).advertisementsList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdvertisementsApi - factory interface
 * @export
 */
export const AdvertisementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @param {Advertisement} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advertisementsCreate(data: Advertisement, options?: any) {
            return AdvertisementsApiFp(configuration).advertisementsCreate(data, options)(axios, basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advertisementsList(options?: any) {
            return AdvertisementsApiFp(configuration).advertisementsList(options)(axios, basePath);
        },
    };
};

/**
 * AdvertisementsApi - object-oriented interface
 * @export
 * @class AdvertisementsApi
 * @extends {BaseAPI}
 */
export class AdvertisementsApi extends BaseAPI {
    /**
     *
     * @param {Advertisement} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvertisementsApi
     */
    public advertisementsCreate(data: Advertisement, options?: any) {
        return AdvertisementsApiFp(this.configuration).advertisementsCreate(data, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvertisementsApi
     */
    public advertisementsList(options?: any) {
        return AdvertisementsApiFp(this.configuration).advertisementsList(options)(this.axios, this.basePath);
    }

}


/**
 * AnnouncementsApi - axios parameter creator
 * @export
 */
export const AnnouncementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Announcement} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementsCreate(data: Announcement, options: any = {}): RequestArgs {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling announcementsCreate.');
            }
            const localVarPath = `/announcements/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"Announcement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} topic A unique value identifying this announcement.
         * @param {Announcement} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementsPartialUpdate(topic: string, data: Announcement, options: any = {}): RequestArgs {
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling announcementsPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling announcementsPartialUpdate.');
            }
            const localVarPath = `/announcements/{topic}/`
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"Announcement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} topic A unique value identifying this announcement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementsRead(topic: string, options: any = {}): RequestArgs {
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling announcementsRead.');
            }
            const localVarPath = `/announcements/{topic}/`
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} topic A unique value identifying this announcement.
         * @param {Announcement} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementsUpdate(topic: string, data: Announcement, options: any = {}): RequestArgs {
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling announcementsUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling announcementsUpdate.');
            }
            const localVarPath = `/announcements/{topic}/`
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"Announcement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnouncementsApi - functional programming interface
 * @export
 */
export const AnnouncementsApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {Announcement} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementsCreate(data: Announcement, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement> {
            const localVarAxiosArgs = AnnouncementsApiAxiosParamCreator(configuration).announcementsCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} topic A unique value identifying this announcement.
         * @param {Announcement} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementsPartialUpdate(topic: string, data: Announcement, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement> {
            const localVarAxiosArgs = AnnouncementsApiAxiosParamCreator(configuration).announcementsPartialUpdate(topic, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} topic A unique value identifying this announcement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementsRead(topic: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement> {
            const localVarAxiosArgs = AnnouncementsApiAxiosParamCreator(configuration).announcementsRead(topic, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} topic A unique value identifying this announcement.
         * @param {Announcement} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementsUpdate(topic: string, data: Announcement, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement> {
            const localVarAxiosArgs = AnnouncementsApiAxiosParamCreator(configuration).announcementsUpdate(topic, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AnnouncementsApi - factory interface
 * @export
 */
export const AnnouncementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @param {Announcement} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementsCreate(data: Announcement, options?: any) {
            return AnnouncementsApiFp(configuration).announcementsCreate(data, options)(axios, basePath);
        },
        /**
         *
         * @param {string} topic A unique value identifying this announcement.
         * @param {Announcement} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementsPartialUpdate(topic: string, data: Announcement, options?: any) {
            return AnnouncementsApiFp(configuration).announcementsPartialUpdate(topic, data, options)(axios, basePath);
        },
        /**
         *
         * @param {string} topic A unique value identifying this announcement.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementsRead(topic: string, options?: any) {
            return AnnouncementsApiFp(configuration).announcementsRead(topic, options)(axios, basePath);
        },
        /**
         *
         * @param {string} topic A unique value identifying this announcement.
         * @param {Announcement} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementsUpdate(topic: string, data: Announcement, options?: any) {
            return AnnouncementsApiFp(configuration).announcementsUpdate(topic, data, options)(axios, basePath);
        },
    };
};

/**
 * AnnouncementsApi - object-oriented interface
 * @export
 * @class AnnouncementsApi
 * @extends {BaseAPI}
 */
export class AnnouncementsApi extends BaseAPI {
    /**
     *
     * @param {Announcement} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public announcementsCreate(data: Announcement, options?: any) {
        return AnnouncementsApiFp(this.configuration).announcementsCreate(data, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} topic A unique value identifying this announcement.
     * @param {Announcement} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public announcementsPartialUpdate(topic: string, data: Announcement, options?: any) {
        return AnnouncementsApiFp(this.configuration).announcementsPartialUpdate(topic, data, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} topic A unique value identifying this announcement.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public announcementsRead(topic: string, options?: any) {
        return AnnouncementsApiFp(this.configuration).announcementsRead(topic, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} topic A unique value identifying this announcement.
     * @param {Announcement} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public announcementsUpdate(topic: string, data: Announcement, options?: any) {
        return AnnouncementsApiFp(this.configuration).announcementsUpdate(topic, data, options)(this.axios, this.basePath);
    }

}


/**
 * ChatsApi - axios parameter creator
 * @export
 */
export const ChatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsList(options: any = {}): RequestArgs {
            const localVarPath = `/chats/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsMessages(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling chatsMessages.');
            }
            const localVarPath = `/chats/{id}/messages/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatsApi - functional programming interface
 * @export
 */
export const ChatsApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Chat>> {
            const localVarAxiosArgs = ChatsApiAxiosParamCreator(configuration).chatsList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsMessages(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message> {
            const localVarAxiosArgs = ChatsApiAxiosParamCreator(configuration).chatsMessages(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ChatsApi - factory interface
 * @export
 */
export const ChatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsList(options?: any) {
            return ChatsApiFp(configuration).chatsList(options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsMessages(id: string, options?: any) {
            return ChatsApiFp(configuration).chatsMessages(id, options)(axios, basePath);
        },
    };
};

/**
 * ChatsApi - object-oriented interface
 * @export
 * @class ChatsApi
 * @extends {BaseAPI}
 */
export class ChatsApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsList(options?: any) {
        return ChatsApiFp(this.configuration).chatsList(options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsMessages(id: string, options?: any) {
        return ChatsApiFp(this.configuration).chatsMessages(id, options)(this.axios, this.basePath);
    }

}


/**
 * DiscussionTopicsApi - axios parameter creator
 * @export
 */
export const DiscussionTopicsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [maxid] The pagination cursor value.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discussionTopicsList(maxid?: string, pageSize?: number, options: any = {}): RequestArgs {
            const localVarPath = `/discussion_topics/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (maxid !== undefined) {
                localVarQueryParameter['maxid'] = maxid;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiscussionTopicsApi - functional programming interface
 * @export
 */
export const DiscussionTopicsApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} [maxid] The pagination cursor value.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discussionTopicsList(maxid?: string, pageSize?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200> {
            const localVarAxiosArgs = DiscussionTopicsApiAxiosParamCreator(configuration).discussionTopicsList(maxid, pageSize, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DiscussionTopicsApi - factory interface
 * @export
 */
export const DiscussionTopicsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @param {string} [maxid] The pagination cursor value.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discussionTopicsList(maxid?: string, pageSize?: number, options?: any) {
            return DiscussionTopicsApiFp(configuration).discussionTopicsList(maxid, pageSize, options)(axios, basePath);
        },
    };
};

/**
 * DiscussionTopicsApi - object-oriented interface
 * @export
 * @class DiscussionTopicsApi
 * @extends {BaseAPI}
 */
export class DiscussionTopicsApi extends BaseAPI {
    /**
     *
     * @param {string} [maxid] The pagination cursor value.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscussionTopicsApi
     */
    public discussionTopicsList(maxid?: string, pageSize?: number, options?: any) {
        return DiscussionTopicsApiFp(this.configuration).discussionTopicsList(maxid, pageSize, options)(this.axios, this.basePath);
    }

}


/**
 * InitiativesApi - axios parameter creator
 * @export
 */
export const InitiativesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {Initiative} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesAddStep(topic: string, data: Initiative, options: any = {}): RequestArgs {
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling initiativesAddStep.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling initiativesAddStep.');
            }
            const localVarPath = `/initiatives/{topic}/add_step/`
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"Initiative" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {Initiative} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesCreate(data: Initiative, options: any = {}): RequestArgs {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling initiativesCreate.');
            }
            const localVarPath = `/initiatives/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"Initiative" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {InitiativeFeedback} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesFeedback(topic: string, data: InitiativeFeedback, options: any = {}): RequestArgs {
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling initiativesFeedback.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling initiativesFeedback.');
            }
            const localVarPath = `/initiatives/{topic}/feedback/`
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"InitiativeFeedback" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {Initiative} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesPartialUpdate(topic: string, data: Initiative, options: any = {}): RequestArgs {
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling initiativesPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling initiativesPartialUpdate.');
            }
            const localVarPath = `/initiatives/{topic}/`
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"Initiative" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesRead(topic: string, options: any = {}): RequestArgs {
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling initiativesRead.');
            }
            const localVarPath = `/initiatives/{topic}/`
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {Initiative} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesUpdate(topic: string, data: Initiative, options: any = {}): RequestArgs {
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling initiativesUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling initiativesUpdate.');
            }
            const localVarPath = `/initiatives/{topic}/`
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"Initiative" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InitiativesApi - functional programming interface
 * @export
 */
export const InitiativesApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {Initiative} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesAddStep(topic: string, data: Initiative, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Initiative> {
            const localVarAxiosArgs = InitiativesApiAxiosParamCreator(configuration).initiativesAddStep(topic, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {Initiative} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesCreate(data: Initiative, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Initiative> {
            const localVarAxiosArgs = InitiativesApiAxiosParamCreator(configuration).initiativesCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {InitiativeFeedback} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesFeedback(topic: string, data: InitiativeFeedback, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitiativeFeedback> {
            const localVarAxiosArgs = InitiativesApiAxiosParamCreator(configuration).initiativesFeedback(topic, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {Initiative} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesPartialUpdate(topic: string, data: Initiative, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Initiative> {
            const localVarAxiosArgs = InitiativesApiAxiosParamCreator(configuration).initiativesPartialUpdate(topic, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesRead(topic: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Initiative> {
            const localVarAxiosArgs = InitiativesApiAxiosParamCreator(configuration).initiativesRead(topic, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {Initiative} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesUpdate(topic: string, data: Initiative, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Initiative> {
            const localVarAxiosArgs = InitiativesApiAxiosParamCreator(configuration).initiativesUpdate(topic, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InitiativesApi - factory interface
 * @export
 */
export const InitiativesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {Initiative} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesAddStep(topic: string, data: Initiative, options?: any) {
            return InitiativesApiFp(configuration).initiativesAddStep(topic, data, options)(axios, basePath);
        },
        /**
         *
         * @param {Initiative} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesCreate(data: Initiative, options?: any) {
            return InitiativesApiFp(configuration).initiativesCreate(data, options)(axios, basePath);
        },
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {InitiativeFeedback} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesFeedback(topic: string, data: InitiativeFeedback, options?: any) {
            return InitiativesApiFp(configuration).initiativesFeedback(topic, data, options)(axios, basePath);
        },
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {Initiative} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesPartialUpdate(topic: string, data: Initiative, options?: any) {
            return InitiativesApiFp(configuration).initiativesPartialUpdate(topic, data, options)(axios, basePath);
        },
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesRead(topic: string, options?: any) {
            return InitiativesApiFp(configuration).initiativesRead(topic, options)(axios, basePath);
        },
        /**
         *
         * @param {string} topic A unique value identifying this initiative.
         * @param {Initiative} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiativesUpdate(topic: string, data: Initiative, options?: any) {
            return InitiativesApiFp(configuration).initiativesUpdate(topic, data, options)(axios, basePath);
        },
    };
};

/**
 * InitiativesApi - object-oriented interface
 * @export
 * @class InitiativesApi
 * @extends {BaseAPI}
 */
export class InitiativesApi extends BaseAPI {
    /**
     *
     * @param {string} topic A unique value identifying this initiative.
     * @param {Initiative} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InitiativesApi
     */
    public initiativesAddStep(topic: string, data: Initiative, options?: any) {
        return InitiativesApiFp(this.configuration).initiativesAddStep(topic, data, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {Initiative} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InitiativesApi
     */
    public initiativesCreate(data: Initiative, options?: any) {
        return InitiativesApiFp(this.configuration).initiativesCreate(data, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} topic A unique value identifying this initiative.
     * @param {InitiativeFeedback} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InitiativesApi
     */
    public initiativesFeedback(topic: string, data: InitiativeFeedback, options?: any) {
        return InitiativesApiFp(this.configuration).initiativesFeedback(topic, data, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} topic A unique value identifying this initiative.
     * @param {Initiative} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InitiativesApi
     */
    public initiativesPartialUpdate(topic: string, data: Initiative, options?: any) {
        return InitiativesApiFp(this.configuration).initiativesPartialUpdate(topic, data, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} topic A unique value identifying this initiative.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InitiativesApi
     */
    public initiativesRead(topic: string, options?: any) {
        return InitiativesApiFp(this.configuration).initiativesRead(topic, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} topic A unique value identifying this initiative.
     * @param {Initiative} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InitiativesApi
     */
    public initiativesUpdate(topic: string, data: Initiative, options?: any) {
        return InitiativesApiFp(this.configuration).initiativesUpdate(topic, data, options)(this.axios, this.basePath);
    }

}


/**
 * JwtLoginApi - axios parameter creator
 * @export
 */
export const JwtLoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Метод API, который принимает POST с типом аккаунта (email|phone), логином и паролем пользователя. Возвращает токен для аутентификации в Hakathon и идентификатор пользователя.
         * @param {JSONWebToken} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtLoginCreate(data: JSONWebToken, options: any = {}): RequestArgs {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling jwtLoginCreate.');
            }
            const localVarPath = `/jwt-login/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"JSONWebToken" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JwtLoginApi - functional programming interface
 * @export
 */
export const JwtLoginApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Метод API, который принимает POST с типом аккаунта (email|phone), логином и паролем пользователя. Возвращает токен для аутентификации в Hakathon и идентификатор пользователя.
         * @param {JSONWebToken} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtLoginCreate(data: JSONWebToken, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JSONWebTokenResponse> {
            const localVarAxiosArgs = JwtLoginApiAxiosParamCreator(configuration).jwtLoginCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * JwtLoginApi - factory interface
 * @export
 */
export const JwtLoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Метод API, который принимает POST с типом аккаунта (email|phone), логином и паролем пользователя. Возвращает токен для аутентификации в Hakathon и идентификатор пользователя.
         * @param {JSONWebToken} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtLoginCreate(data: JSONWebToken, options?: any) {
            return JwtLoginApiFp(configuration).jwtLoginCreate(data, options)(axios, basePath);
        },
    };
};

/**
 * JwtLoginApi - object-oriented interface
 * @export
 * @class JwtLoginApi
 * @extends {BaseAPI}
 */
export class JwtLoginApi extends BaseAPI {
    /**
     * Метод API, который принимает POST с типом аккаунта (email|phone), логином и паролем пользователя. Возвращает токен для аутентификации в Hakathon и идентификатор пользователя.
     * @param {JSONWebToken} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JwtLoginApi
     */
    public jwtLoginCreate(data: JSONWebToken, options?: any) {
        return JwtLoginApiFp(this.configuration).jwtLoginCreate(data, options)(this.axios, this.basePath);
    }

}


/**
 * JwtRefreshApi - axios parameter creator
 * @export
 */
export const JwtRefreshApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Метод API, который возвращает обновленный токен для аутентификации (с новым expiration) на основании текущего токена
         * @param {RefreshJSONWebToken} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtRefreshCreate(data: RefreshJSONWebToken, options: any = {}): RequestArgs {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling jwtRefreshCreate.');
            }
            const localVarPath = `/jwt-refresh/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"RefreshJSONWebToken" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JwtRefreshApi - functional programming interface
 * @export
 */
export const JwtRefreshApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Метод API, который возвращает обновленный токен для аутентификации (с новым expiration) на основании текущего токена
         * @param {RefreshJSONWebToken} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtRefreshCreate(data: RefreshJSONWebToken, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshJSONWebToken> {
            const localVarAxiosArgs = JwtRefreshApiAxiosParamCreator(configuration).jwtRefreshCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * JwtRefreshApi - factory interface
 * @export
 */
export const JwtRefreshApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Метод API, который возвращает обновленный токен для аутентификации (с новым expiration) на основании текущего токена
         * @param {RefreshJSONWebToken} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jwtRefreshCreate(data: RefreshJSONWebToken, options?: any) {
            return JwtRefreshApiFp(configuration).jwtRefreshCreate(data, options)(axios, basePath);
        },
    };
};

/**
 * JwtRefreshApi - object-oriented interface
 * @export
 * @class JwtRefreshApi
 * @extends {BaseAPI}
 */
export class JwtRefreshApi extends BaseAPI {
    /**
     * Метод API, который возвращает обновленный токен для аутентификации (с новым expiration) на основании текущего токена
     * @param {RefreshJSONWebToken} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JwtRefreshApi
     */
    public jwtRefreshCreate(data: RefreshJSONWebToken, options?: any) {
        return JwtRefreshApiFp(this.configuration).jwtRefreshCreate(data, options)(this.axios, this.basePath);
    }

}


/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Message} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesCreate(data: Message, options: any = {}): RequestArgs {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling messagesCreate.');
            }
            const localVarPath = `/messages/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"Message" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDelete(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling messagesDelete.');
            }
            const localVarPath = `/messages/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {Message} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesCreate(data: Message, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message> {
            const localVarAxiosArgs = MessagesApiAxiosParamCreator(configuration).messagesCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDelete(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = MessagesApiAxiosParamCreator(configuration).messagesDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @param {Message} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesCreate(data: Message, options?: any) {
            return MessagesApiFp(configuration).messagesCreate(data, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDelete(id: string, options?: any) {
            return MessagesApiFp(configuration).messagesDelete(id, options)(axios, basePath);
        },
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     *
     * @param {Message} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesCreate(data: Message, options?: any) {
        return MessagesApiFp(this.configuration).messagesCreate(data, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesDelete(id: string, options?: any) {
        return MessagesApiFp(this.configuration).messagesDelete(id, options)(this.axios, this.basePath);
    }

}


/**
 * RefreshTokenApi - axios parameter creator
 * @export
 */
export const RefreshTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Метод для закрытия сессии через refresh_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenLogoutCreate(options: any = {}): RequestArgs {
            const localVarPath = `/refresh-token/logout/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод для обновления auth_token используя refresh_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenRefreshCreate(options: any = {}): RequestArgs {
            const localVarPath = `/refresh-token/refresh/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefreshTokenApi - functional programming interface
 * @export
 */
export const RefreshTokenApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Метод для закрытия сессии через refresh_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenLogoutCreate(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = RefreshTokenApiAxiosParamCreator(configuration).refreshTokenLogoutCreate(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Метод для обновления auth_token используя refresh_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenRefreshCreate(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = RefreshTokenApiAxiosParamCreator(configuration).refreshTokenRefreshCreate(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RefreshTokenApi - factory interface
 * @export
 */
export const RefreshTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Метод для закрытия сессии через refresh_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenLogoutCreate(options?: any) {
            return RefreshTokenApiFp(configuration).refreshTokenLogoutCreate(options)(axios, basePath);
        },
        /**
         * Метод для обновления auth_token используя refresh_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenRefreshCreate(options?: any) {
            return RefreshTokenApiFp(configuration).refreshTokenRefreshCreate(options)(axios, basePath);
        },
    };
};

/**
 * RefreshTokenApi - object-oriented interface
 * @export
 * @class RefreshTokenApi
 * @extends {BaseAPI}
 */
export class RefreshTokenApi extends BaseAPI {
    /**
     * Метод для закрытия сессии через refresh_token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefreshTokenApi
     */
    public refreshTokenLogoutCreate(options?: any) {
        return RefreshTokenApiFp(this.configuration).refreshTokenLogoutCreate(options)(this.axios, this.basePath);
    }

    /**
     * Метод для обновления auth_token используя refresh_token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefreshTokenApi
     */
    public refreshTokenRefreshCreate(options?: any) {
        return RefreshTokenApiFp(this.configuration).refreshTokenRefreshCreate(options)(this.axios, this.basePath);
    }

}


/**
 * UserDevicesApi - axios parameter creator
 * @export
 */
export const UserDevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {UserDevice} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDevicesCreate(data: UserDevice, options: any = {}): RequestArgs {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling userDevicesCreate.');
            }
            const localVarPath = `/user-devices/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"UserDevice" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDevicesDelete(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userDevicesDelete.');
            }
            const localVarPath = `/user-devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDevicesList(options: any = {}): RequestArgs {
            const localVarPath = `/user-devices/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDevicesRead(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userDevicesRead.');
            }
            const localVarPath = `/user-devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserDevicesApi - functional programming interface
 * @export
 */
export const UserDevicesApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {UserDevice} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDevicesCreate(data: UserDevice, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDevice> {
            const localVarAxiosArgs = UserDevicesApiAxiosParamCreator(configuration).userDevicesCreate(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDevicesDelete(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UserDevicesApiAxiosParamCreator(configuration).userDevicesDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDevicesList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDevice>> {
            const localVarAxiosArgs = UserDevicesApiAxiosParamCreator(configuration).userDevicesList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDevicesRead(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDevice> {
            const localVarAxiosArgs = UserDevicesApiAxiosParamCreator(configuration).userDevicesRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserDevicesApi - factory interface
 * @export
 */
export const UserDevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @param {UserDevice} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDevicesCreate(data: UserDevice, options?: any) {
            return UserDevicesApiFp(configuration).userDevicesCreate(data, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDevicesDelete(id: string, options?: any) {
            return UserDevicesApiFp(configuration).userDevicesDelete(id, options)(axios, basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDevicesList(options?: any) {
            return UserDevicesApiFp(configuration).userDevicesList(options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDevicesRead(id: string, options?: any) {
            return UserDevicesApiFp(configuration).userDevicesRead(id, options)(axios, basePath);
        },
    };
};

/**
 * UserDevicesApi - object-oriented interface
 * @export
 * @class UserDevicesApi
 * @extends {BaseAPI}
 */
export class UserDevicesApi extends BaseAPI {
    /**
     *
     * @param {UserDevice} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDevicesApi
     */
    public userDevicesCreate(data: UserDevice, options?: any) {
        return UserDevicesApiFp(this.configuration).userDevicesCreate(data, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDevicesApi
     */
    public userDevicesDelete(id: string, options?: any) {
        return UserDevicesApiFp(this.configuration).userDevicesDelete(id, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDevicesApi
     */
    public userDevicesList(options?: any) {
        return UserDevicesApiFp(this.configuration).userDevicesList(options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDevicesApi
     */
    public userDevicesRead(id: string, options?: any) {
        return UserDevicesApiFp(this.configuration).userDevicesRead(id, options)(this.axios, this.basePath);
    }

}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRead(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersRead.');
            }
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...baseOptions.headers, ...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRead(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).usersRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRead(id: string, options?: any) {
            return UsersApiFp(configuration).usersRead(id, options)(axios, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRead(id: string, options?: any) {
        return UsersApiFp(this.configuration).usersRead(id, options)(this.axios, this.basePath);
    }

}


